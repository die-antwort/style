# For Rubocop version: 1.50

AllCops:
  NewCops: enable


Metrics/AbcSize:
  Enabled: false

Metrics/BlockLength:
  Enabled: false

Metrics/CollectionLiteralLength:
  Enabled: false

Metrics/CyclomaticComplexity:
  Enabled: false

Metrics/ParameterLists:
  Enabled: false

Metrics/PerceivedComplexity:
  Enabled: false

Metrics/ClassLength:
  Enabled: false

Metrics/MethodLength:
  Enabled: false

Metrics/ModuleLength:
  Enabled: false


Lint/AmbiguousBlockAssociation: # Allow idiomatic use in RSpec expectations
  AllowedPatterns: "change"

Lint/AmbiguousOperatorPrecedence:
  Enabled: false

Lint/DuplicateBranch:
  Enabled: false

Lint/SymbolConversion:
  Enabled: false


Naming/AccessorMethodName:
  Enabled: false

Naming/BlockForwarding:
  Enabled: false

Naming/BlockParameterName: # If a param name is “communicative” can’t be decided based only on syntax
  Enabled: false

Naming/MethodParameterName: # If a param name is “communicative” can’t be decided based only on syntax
  Enabled: false

Naming/RescuedExceptionsVariableName:
  Enabled: false

Naming/VariableNumber: # Both kinds of adding numbers to variables are okay (with and without underscore)
  Enabled: false


Style/AccessorGrouping:
  Enabled: false

Style/AndOr: # `and` and `or` may be used for control flow (but not in conditionals)
  EnforcedStyle: conditionals

Style/ArrayIntersect:
  Enabled: false

Style/AsciiComments: # Typographic quotes etc. are perfectly okay in comments
  Enabled: false

Style/BlockDelimiters: # Both do…end and {…} are okay for all kinds of blocks
  Enabled: false

Style/CaseLikeIf:
  Enabled: false

Style/ClassAndModuleChildren: # Both nested and compact namespacing is okay
  Enabled: false

Style/CombinableLoops:
  Enabled: false

Style/CommentAnnotation:
  Enabled: false

Style/CommentedKeyword:
  Enabled: false

Style/DocumentDynamicEvalDefinition:
  Enabled: false

Style/Documentation:
  Enabled: false

Style/EmptyCaseCondition: # Sometimes a case statement reads better than if … elsif … end
  Enabled: false

Style/ExplicitBlockArgument:
  Enabled: false

Style/FetchEnvVar:
  Enabled: false

Style/FormatString: # All `sprintf`, `format`, and `%` are okay for formatting strings
  Enabled: false

Style/FormatStringToken:
  Enabled: false

Style/FrozenStringLiteralComment: # We enable explicitly on a per-project basis, if needed
  Enabled: false

Style/GuardClause: # Sometimes using a guard clause makes the code harder to follow
  Enabled: false

Style/HashLikeCase:
  Enabled: false

Style/HashSyntax:
  Enabled: false

Style/IfUnlessModifier: # Sometimes using a modifier makes the code harder to read
  Enabled: false

Style/Lambda: # Both `->` and `lambda` are okay for all kinds of procs
  Enabled: false

Style/LambdaCall: # Allow idiomatic Jbuilder usage `json.(@foo, :bar, :baz)`
  Exclude:
    -  '**/*.jbuilder'

Style/MultilineBlockChain:
  Enabled: false

Style/NegatedIf:
  Enabled: false

Style/NegatedIfElseCondition:
  Enabled: false

Style/NumericLiterals:
  Enabled: false

Style/NumericPredicate: # Using `== 0` is okay (in some cases at least)
  Enabled: false

Style/OpenStructUse:
  Enabled: false

Style/ParallelAssignment: # Parallel assignment is ok for simple cases
  Enabled: false

Style/PerlBackrefs: # Perl-style regex backrefs (`$1`, …) are short and sweet
  Enabled: false

Style/QuotedSymbols:
  Enabled: false

Style/RedundantInitialize:
  Enabled: false

Style/RedundantReturn: # Sometimes an explicit `return` makes the code more clear
  Enabled: false

Style/RedundantSort: # When used with non-numeric arrays, `#min` / `#max` is not really intuitive
  Enabled: false

Style/RegexpLiteral: # `%r{...}` is fine even for simple regexps
  Enabled: false

Style/SafeNavigation:
  Enabled: false

Style/Semicolon:
  AllowAsExpressionSeparator: true

Style/SoleNestedConditional:
  Enabled: false

Style/SpecialGlobalVars: # `$!` is okay, and we don’t use the other Perl-ish globals anyway
  Enabled: false

Style/StringConcatenation:
  Enabled: false

Style/SingleLineBlockParams: # Block params should be as meaningful as possible
  Enabled: false

Style/StringLiterals: # Both '…' and "…" are okay for all kinds of strings
  Enabled: false

Style/SymbolProc:
  AllowMethodsWithArguments: true

Style/TrailingCommaInArguments: # Multiline parameter might use trailing commas (like in literals)
  Enabled: false

Style/TrailingCommaInArrayLiteral:
  EnforcedStyleForMultiline: comma

Style/TrailingCommaInHashLiteral:
  EnforcedStyleForMultiline: comma

Style/WhileUntilModifier:
  Enabled: false

Style/WordArray: # Especially in nested arrays consistence is important (even if some of the inner arrays could be replace by word arrays)
  Enabled: false


Layout/ArgumentAlignment:
  EnforcedStyle: with_fixed_indentation

Layout/DotPosition: # Trailing dot works better with intermittent blank lines and copy-pasting into irb
  EnforcedStyle: trailing

Layout/EmptyLines: # Consecutive empty lines are sometimes useful for additional structure
  Enabled: false

Layout/EmptyLineAfterGuardClause:
  Enabled: false

Layout/EmptyLinesAroundAttributeAccessor:
  Enabled: false

Layout/EmptyLineBetweenDefs: # Single line method definitions don’t need blank lines in-between them.
  AllowAdjacentOneLineDefs: true
  NumberOfEmptyLines: [1, 3]

Layout/FirstArrayElementIndentation:
  EnforcedStyle: consistent

Layout/FirstHashElementIndentation:
  EnforcedStyle: consistent

Layout/HashAlignment:
  EnforcedColonStyle: [key, table]
  EnforcedHashRocketStyle: [key, table]

Layout/LineLength:
  Enabled: false

Layout/MultilineBlockLayout:
  Enabled: false

Layout/MultilineMethodCallIndentation:
  EnforcedStyle: indented

Layout/ParameterAlignment:
  EnforcedStyle: with_fixed_indentation

Layout/SpaceBeforeBlockBraces:
  EnforcedStyle: no_space
  EnforcedStyleForEmptyBraces: no_space

Layout/SpaceInsideHashLiteralBraces:
  EnforcedStyle: no_space
